"""
22 may 2015
"""

from pytadbit.utils.file_handling import magic_open
from bisect import bisect_right as bisect
from pytadbit.mapping.restriction_enzymes import map_re_sites
from subprocess import Popen, PIPE
from warnings import warn
import os

def parse_map(f_names1, f_names2=None, out_file1=None, out_file2=None,
              genome_seq=None, re_name=None, verbose=False, clean=True,
              **kwargs):
    """
    Parse map files

    Keep a summary of the results into 2 tab-separated files that will contain 6
    columns: read ID, Chromosome, position, strand (either 0 or 1), mapped
    sequence lebgth, position of the closest upstream RE site, position of
    the closest downstream RE site.

    The position of reads mapped on reverse strand will be computed from the end of
    the read (original position + read length - 1)

    :param f_names1: a list of path to sam/bam files corresponding to the
       mapping of read1, can also  be just one file
    :param f_names2: a list of path to sam/bam files corresponding to the
       mapping of read2, can also  be just one file
    :param out_file1: path to outfile tab separated format containing mapped
       read1 information
    :param out_file2: path to outfile tab separated format containing mapped
       read2 information
    :param genome_seq: a dictionary generated by :func:`pyatdbit.parser.genome_parser.parse_fasta`.
       containing the genomic sequence
    :param re_name: name of the restriction enzyme used
    :param True clean: remove temporary files required for indentification of
       multiple-contacts
    """
    # not nice, dirty fix in order to allow this function to only parse
    # one SAM file
    if not out_file1:
        raise Exception('ERROR: out_file1 should be given\n')
    if not re_name:
        raise Exception('ERROR: re_name should be given\n')
    if not genome_seq:
        raise Exception('ERROR: genome_seq should be given\n')
    if (f_names2 and not out_file2) or (not f_names2 and out_file2):
        raise Exception('ERROR: out_file2 AND f_names2 needed\n')

    frag_chunk = kwargs.get('frag_chunk', 100000)
    if verbose:
        print 'Searching and mapping RE sites to the reference genome'
    frags = map_re_sites(re_name, genome_seq, frag_chunk=frag_chunk,
                         verbose=verbose)

    if isinstance(f_names1, str):
        f_names1 = [f_names1]
    if isinstance(f_names2, str):
        f_names2 = [f_names2]
    if f_names2:
        fnames = f_names1, f_names2
        outfiles = out_file1, out_file2
    else:
        fnames = (f_names1,)
        outfiles = (out_file1, )

    windows = {}
    for read in range(len(fnames)):
        if verbose:
            print 'Loading read' + str(read + 1)
        windows[read] = {}
        tmp_name = os.path.join(*outfiles[read].split('/')[:-1] +
                                ['tmp_' + outfiles[read].split('/')[-1]])
        tmp_name = ('/' * outfiles[read].startswith('/')) + tmp_name
        tmp_reads_fh = open(tmp_name, 'w')
        sorter = Popen(['sort', '-k', '1,1', '-s', '-t', '\t'], stdin=PIPE,
                       stdout=tmp_reads_fh)
        num = 0
        for fnam in fnames[read]:
            try:
                fhandler = magic_open(fnam)
            except IOError:
                warn('WARNING: file "%s" not found\n' % fnam)
                continue
            # get the iteration number of the iterative mapping
            try:
                num = int(fnam.split('.')[-1].split(':')[0])
            except:
                num += 1
            windows[read].setdefault(num, 0)
            if verbose:
                print 'loading file: %s' % (fnam)
            # iteration over reads
            for r in fhandler:
                name, seq, _, _, ali = r.split('\t')[:5]
                crm, strand, pos = ali.split(':')[:3]
                positive = strand == '+'
                len_seq  = len(seq)
                if positive:
                    pos = int(pos)
                else:
                    pos = int(pos) + len_seq - 1 # remove 1 because all inclusive
                try:
                    frag_piece = frags[crm][pos / frag_chunk]
                except KeyError:
                    # Chromosome not in hash
                    continue
                idx = bisect(frag_piece, pos)
                try:
                    next_re = frag_piece[idx]
                except IndexError:
                    # case where part of the read is mapped outside chromosome
                    count = 0
                    while idx >= len(frag_piece) and count < len_seq:
                        pos -= 1
                        count += 1
                        frag_piece = frags[crm][pos / frag_chunk]
                        idx = bisect(frag_piece, pos)
                    if count >= len_seq:
                        raise Exception('Read mapped mostly outside ' +
                                        'chromosome\n')
                    next_re = frag_piece[idx]
                prev_re = frag_piece[idx - 1 if idx else 0]
                sorter.stdin.write('%s\t%s\t%d\t%d\t%d\t%d\t%d\n' % (
                    name, crm, pos, positive, len_seq, prev_re, next_re))
                windows[read][num] += 1
        
        if verbose:
            print 'finishing to sort'
        sorter.communicate()
        tmp_reads_fh.close()

        if verbose:
            print 'Getting Multiple contacts'
        reads_fh = open(outfiles[read], 'w')
        ## Also pipe file header
        # chromosome sizes (in order)
        reads_fh.write('# Chromosome lengths (order matters):\n')
        for crm in genome_seq:
            reads_fh.write('# CRM %s\t%d\n' % (crm, len(genome_seq[crm])))
        reads_fh.write('# Mapped\treads count by iteration\n')
        for size in windows[read]:
            reads_fh.write('# MAPPED %d %d\n' % (size, windows[read][size]))

        ## Multicontacts
        tmp_reads_fh = open(tmp_name)
        read = tmp_reads_fh.next()
        prev_head = read.split('\t', 1)[0]
        prev_head = prev_head.split('~' , 1)[0]
        prev_read = read
        for read in tmp_reads_fh:
            head = read.split('\t', 1)[0]
            head = head.split('~' , 1)[0]
            if head == prev_head:
                prev_read =  prev_read.strip() + '|||' + read
            else:
                reads_fh.write(prev_read)
                prev_read = read
            prev_head = head
        reads_fh.write(prev_read)
        reads_fh.close()

        if clean:
            os.system('rm -rf ' + tmp_name)
    return windows
